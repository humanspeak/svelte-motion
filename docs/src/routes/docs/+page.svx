---
title: "Get started with Svelte Motion"
description: "Svelte Motion is a Svelte animation library for building smooth, production-grade UI animations."
---

<script>
  import { motion } from '@humanspeak/svelte-motion';
</script>

# Get started with Svelte Motion

**Svelte Motion** is a Svelte animation library for building smooth, production-grade UI animations. You can start with simple prop-based animations before growing to layout, gesture and scroll animations.

Svelte Motion's unique **hybrid engine** combines the performance of native browser animations with the flexibility of JavaScript. It's designed to feel like a natural extension of Svelte's reactive philosophy.

In this guide, we'll learn **why** and **when** you should use Svelte Motion, how to **install** it, and then take a whirlwind tour of its main features.

## Why Svelte Motion?

Svelte gives you the power to build dynamic user interfaces with excellent performance out of the box. Svelte Motion extends this power to animations, making it simple to create everything from beautiful micro-interactions to complex, gesture-driven animations.

```svelte
<script>
  import { motion } from '@humanspeak/svelte-motion';
</script>

<motion.button animate={{ opacity: 1 }}>
  Animated Button
</motion.button>
```

### Key advantages

Here's when it's the right choice for your project.

- **Built for Svelte.** While other animation libraries can feel foreign, Svelte Motion's API feels like a natural extension of Svelte. Animations can be linked directly to reactive state and props.
- **Hardware-acceleration.** Svelte Motion leverages the same high-performance browser animations as pure CSS, ensuring your UIs stay smooth and snappy. You get the power of 120fps animations with a much simpler and more expressive API.
- **Animate anything.** CSS has hard limits. There are values you can't animate, keyframes you can't interrupt, staggers that must be hardcoded. Svelte Motion provides a single, consistent API that handles everything from simple transitions to advanced scroll, layout, and gesture-driven effects.
- **App-like gestures.** Standard CSS `:hover` events are unreliable on touch devices. Svelte Motion provides robust, cross-device gesture recognizers for tap, drag, and hover, making it easy to build interactions that feel native and intuitive on any device.

### When is CSS a better choice?

For simple, self-contained effects (like a color change on hover) a standard CSS transition is a lightweight solution. The strength of Svelte Motion is that it can do these simple kinds of animations but also scale to anything you can imagine. All with the same easy to write and maintain API.

## Install

Svelte Motion is available via npm:

```bash
npm install @humanspeak/svelte-motion
```

Features can now be imported:

```javascript
import { motion } from '@humanspeak/svelte-motion'
```

## Your first animation

The `<motion>` component is the core API in Svelte Motion. It's a DOM element, supercharged with animation capabilities.

```svelte
<script>
  import { motion } from '@humanspeak/svelte-motion';
</script>

<motion.ul animate={{ rotate: 360 }}>
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</motion.ul>
```

When values in `animate` change, the component will animate. Svelte Motion has intuitive defaults, but animations can of course be configured via the `transition` prop.

```svelte
<motion.div
  animate={{
    scale: 2,
    transition: { duration: 2 }
  }}
>
  Scaling div
</motion.div>
```

## Enter animation

When a component enters the page, it will automatically animate to the values defined in the `animate` prop.

You can provide values to animate from via the `initial` prop (otherwise these will be read from the DOM).

```svelte
<motion.button initial={{ scale: 0 }} animate={{ scale: 1 }}>
  Scaling button
</motion.button>
```

Or disable this initial animation entirely by setting `initial` to `false`.

```svelte
<motion.button initial={false} animate={{ scale: 1 }}>
  No initial animation
</motion.button>
```

## Hover & tap animation

`<motion>` extends Svelte's event system with powerful gesture animations. It currently supports hover, tap, focus, and drag.

```svelte
<motion.button
  whileHover={{ scale: 1.1 }}
  whileTap={{ scale: 0.95 }}
  onHoverStart={() => console.log('hover started!')}
>
  Interactive button
</motion.button>
```
